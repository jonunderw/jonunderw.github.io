{
  "meta": {
    "title": "Create this Site - The Beginning of My Friendship with AI",
    "date": "2025-08-17T00:00:00.000Z",
    "excerpt": "How I used vibe coding to create this site and blog content creation workflow.",
    "category": "Exploration",
    "readTime": "2 min read",
    "imageUrl": "/images/creating-my-blog.jpeg",
    "published": true,
    "tags": [
      "Vibe-Coding",
      "Prompt-Engineering",
      "Product-Development"
    ],
    "slug": "creating-my-blog"
  },
  "html": "<hr>\n<h3>Intro</h3>\n<p>I have always wanted to create my own personal blog as a place to explore and share new ideas, technologies, lessons learned, how-tos, and product and engineering philosophies. I also wanted the freedom to design it without constraints from platforms or template sites.</p>\n<p>With the emergence of vibe coding and other AI tooling, I thought now is the best time to give it a try. I thought that this would also provide a great way to learn and utilize many of the new tools available.</p>\n<p>With these motivations in mind, about six weeks ago, I used a free weekend to start building. This momentum laid the groundwork for a focused approach in planning and design.</p>\n<hr>\n<h3>Getting Started</h3>\n<h5>Design</h5>\n<p>I started by treating this site as a product, so first I defined my primary objectives:</p>\n<ul>\n<li>Clean and customizable UI</li>\n<li>Cost-effective hosting</li>\n<li>Solution for easily adding new content</li>\n<li>Use and improve my skills with AI tooling</li>\n</ul>\n<p>Next, I designed the structure of my site. I landed on a general structure of:</p>\n<ul>\n<li>Home Page - <em>Clean UI that clearly sets the expectation of the content on the site and topics that I explore in my blog posts.</em></li>\n<li>About Page - <em>A place to include all of my Resume or LinkedIn Profile type content, along with more professional and personal timelines, and other personal details.</em></li>\n<li>Blog Page - <em>Landing page for all blog posts</em></li>\n<li>Projects - <em>A page that lists out all of my other Projects within my GitHub. Currently, it is largely just CLI tools that I built to use / experiment with in my day-to-day.</em></li>\n</ul>\n<p>With the design and structure outlined, my next step was to define the tech stack, infrastructure, and scaling strategy (in this case, content generation). These decisions shaped the direction of the site creation and development, as detailed in the following sections.</p>\n<h5>Site Creation, Tech Stack, &#x26; Vibe Coding</h5>\n<p>From there, I began researching how to build the site. I found many blog options, but most required templates or builder UIs, which would limit my customization and AI tool usage. I chose Node, ReactJS with Vite, TypeScript, and Tailwind CSS for styling. I had past experience with AngularJS as an engineer, so I was partial to component-backed frameworks or libraries. I knew I could structure reusable components and debug issues confidently, with CoPilot's help. I had not used React or Tailwind CSS before building this site. I selected this stack after spending a few hours researching and browsing the TailwindCSS site for styling ideas. I set up CoPilot in VS Code and began building, utilizing Vibe coding prompts, context engineering, and testing along the way.  </p>\n<ul>\n<li>For design help, I gave CoPilot screenshots and links to the TailwindCSS features I wanted to use for each page.  </li>\n<li>For setting up the build pipeline locally and remotely, I largely used CoPilot to help troubleshoot along the way. Providing the error output with the context of where the error occurred in the overall pipeline.</li>\n<li>For help with logo creation, I used CoPilot to create SVGs until I decided on the one I liked the most.</li>\n</ul>\n<h5>Hosting and CI/CD pipelines</h5>\n<p>I identified cost-effective hosting and deployment solutions. After comparing options, I chose GitHub Pages and GitHub Actions to automate the publication of new content. Since I was already using GitHub for code, and both services are free with no major limitations, this choice was easy.</p>\n<h5>Content Creation Workflow</h5>\n<p>Next, I planned my content creation workflow. I use Obsidian for nearly everything, so I knew I'd write my blogs in Markdown. I researched workflows for piping Markdown blogs into my site. I explored several static site generators, such as Jekyll, but ultimately built a custom pre-build pipeline with CoPilot and ChatGPT. In short, the workflow goes like this:</p>\n<ul>\n<li>First, I outline the blog I want to write in Obsidian, listing the main topics, subtopics, and overall structure. After gathering enough research, I use NotebookLLM to generate a mind map from this material. Reviewing the mind map helps me ensure that my research aligns with my outline. This step also allows me to identify sections that may require additional detail or refinement.</li>\n<li>Second, I check the mind map for completeness. Once satisfied, I write the first draft of the blog post. While drafting, I use Grammarly AI to help with grammar and consistency. I focus on making the text concise, using visuals or tables for clarity, and keeping my unique perspective. Grammarly's prompts support these goals during the writing process.</li>\n<li>Third, after finalizing the draft, I import it into my site’s repository. To simplify this, I use the Commander extension in Obsidian for one-click automation, instantly moving the blog into the correct folder. I also configure the Homepage and Dataview plugins to display my current blog statuses — In-Progress, In-Planning, Published, and Ice-Boxed topics — automatically every time I open my blog vault.</li>\n<li>Fourth, during the automated build process, I run a Node utility that gathers all markdown files from my blogs folder and generates a JSON file for each one. Each JSON file contains metadata, including image URL, category, tags, references, and title. My reusable blogPost component then uses these JSON files to display the blog posts at runtime, which removes the need to create separate components for every post.  </li>\n<li>Fifth, I update my CSS files to improve the styling within the markdown content of each blog post if needed.  </li>\n</ul>\n<p>Once my site was built, with hosting and CI/CD pipelines running as planned and a viable content creation workflow established, I turned my attention to refining content presentation and adding enhanced media. This brings me to planning the next steps for the blog's growth.  </p>\n<h5>Next Steps</h5>\n<p>Next, I will continue to add more content. I have several topics in progress, from conceptual and informational blogs to more exploratory posts on tools like Loveable, Cursor, Replit, and n8n. I also want to try more Vibe Coding by enhancing my existing CLI tools, exploring some \"big ideas,\" or adding more automation to my daily tasks.  </p>\n<h5>Summary of Tools</h5>\n<p>In conclusion, here's a summary of the full list of tools I used to build this site and how I used them:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table class=\"prose-table w-full my-6 border-collapse\"><thead><tr><th>Tool</th><th>Use-Case</th></tr></thead><tbody><tr><td>GitHub Copilot (Claude Sonnet &#x26; GPT models)</td><td>Vibe Coding, code assistance in VSCode</td></tr><tr><td>VSCode</td><td>IDE for development</td></tr><tr><td>Node</td><td>Tech stack backend development</td></tr><tr><td>ReactJS</td><td>Tech stack frontend development</td></tr><tr><td>Tailwind CSS</td><td>Tech stack styling</td></tr><tr><td>GitHub Copilot</td><td>SVG generation</td></tr><tr><td>MidJourney</td><td>Blog cover photo generation</td></tr><tr><td>ChatGPT, Grok, Perplexity</td><td>Deep search &#x26; research notes</td></tr><tr><td>NotebookLLM, ChatGPT</td><td>Research summarization &#x26; synthesizing</td></tr><tr><td>NotebookLLM</td><td>MindMaps</td></tr><tr><td>Obsidian</td><td>Notes application</td></tr><tr><td>GitHub Pages &#x26; Actions</td><td>Hosting &#x26; automated deployment</td></tr><tr><td>NotebookLLM</td><td>Audio summaries of blogs</td></tr></tbody></table>\n<h5>Conclusion</h5>\n<p>Building this site and exploring new tools has been an eye-opening experience. Although it's still unclear how these changes will affect Product Engineering, I believe these tools will help professionals more than replace us. If there’s one thing I’ve learned, it's that once the change is embraced, the fun actually begins.</p>\n<hr>",
  "content": "\n---\n### Intro  \nI have always wanted to create my own personal blog as a place to explore and share new ideas, technologies, lessons learned, how-tos, and product and engineering philosophies. I also wanted the freedom to design it without constraints from platforms or template sites.\n\nWith the emergence of vibe coding and other AI tooling, I thought now is the best time to give it a try. I thought that this would also provide a great way to learn and utilize many of the new tools available.\n\nWith these motivations in mind, about six weeks ago, I used a free weekend to start building. This momentum laid the groundwork for a focused approach in planning and design.\n\n  \n---  \n### Getting Started\n\n##### Design  \nI started by treating this site as a product, so first I defined my primary objectives:  \n- Clean and customizable UI  \n- Cost-effective hosting  \n- Solution for easily adding new content  \n- Use and improve my skills with AI tooling\n\nNext, I designed the structure of my site. I landed on a general structure of:  \n- Home Page - *Clean UI that clearly sets the expectation of the content on the site and topics that I explore in my blog posts.*  \n- About Page - *A place to include all of my Resume or LinkedIn Profile type content, along with more professional and personal timelines, and other personal details.*  \n- Blog Page - *Landing page for all blog posts*  \n- Projects - *A page that lists out all of my other Projects within my GitHub. Currently, it is largely just CLI tools that I built to use / experiment with in my day-to-day.*\n\nWith the design and structure outlined, my next step was to define the tech stack, infrastructure, and scaling strategy (in this case, content generation). These decisions shaped the direction of the site creation and development, as detailed in the following sections.\n\n##### Site Creation, Tech Stack, & Vibe Coding  \nFrom there, I began researching how to build the site. I found many blog options, but most required templates or builder UIs, which would limit my customization and AI tool usage. I chose Node, ReactJS with Vite, TypeScript, and Tailwind CSS for styling. I had past experience with AngularJS as an engineer, so I was partial to component-backed frameworks or libraries. I knew I could structure reusable components and debug issues confidently, with CoPilot's help. I had not used React or Tailwind CSS before building this site. I selected this stack after spending a few hours researching and browsing the TailwindCSS site for styling ideas. I set up CoPilot in VS Code and began building, utilizing Vibe coding prompts, context engineering, and testing along the way.    \n- For design help, I gave CoPilot screenshots and links to the TailwindCSS features I wanted to use for each page.    \n- For setting up the build pipeline locally and remotely, I largely used CoPilot to help troubleshoot along the way. Providing the error output with the context of where the error occurred in the overall pipeline.  \n- For help with logo creation, I used CoPilot to create SVGs until I decided on the one I liked the most.\n\n##### Hosting and CI/CD pipelines  \nI identified cost-effective hosting and deployment solutions. After comparing options, I chose GitHub Pages and GitHub Actions to automate the publication of new content. Since I was already using GitHub for code, and both services are free with no major limitations, this choice was easy.\n\n##### Content Creation Workflow  \nNext, I planned my content creation workflow. I use Obsidian for nearly everything, so I knew I'd write my blogs in Markdown. I researched workflows for piping Markdown blogs into my site. I explored several static site generators, such as Jekyll, but ultimately built a custom pre-build pipeline with CoPilot and ChatGPT. In short, the workflow goes like this:\n\n- First, I outline the blog I want to write in Obsidian, listing the main topics, subtopics, and overall structure. After gathering enough research, I use NotebookLLM to generate a mind map from this material. Reviewing the mind map helps me ensure that my research aligns with my outline. This step also allows me to identify sections that may require additional detail or refinement.\n- Second, I check the mind map for completeness. Once satisfied, I write the first draft of the blog post. While drafting, I use Grammarly AI to help with grammar and consistency. I focus on making the text concise, using visuals or tables for clarity, and keeping my unique perspective. Grammarly's prompts support these goals during the writing process.\n- Third, after finalizing the draft, I import it into my site’s repository. To simplify this, I use the Commander extension in Obsidian for one-click automation, instantly moving the blog into the correct folder. I also configure the Homepage and Dataview plugins to display my current blog statuses — In-Progress, In-Planning, Published, and Ice-Boxed topics — automatically every time I open my blog vault.\n- Fourth, during the automated build process, I run a Node utility that gathers all markdown files from my blogs folder and generates a JSON file for each one. Each JSON file contains metadata, including image URL, category, tags, references, and title. My reusable blogPost component then uses these JSON files to display the blog posts at runtime, which removes the need to create separate components for every post.  \n- Fifth, I update my CSS files to improve the styling within the markdown content of each blog post if needed.  \n\nOnce my site was built, with hosting and CI/CD pipelines running as planned and a viable content creation workflow established, I turned my attention to refining content presentation and adding enhanced media. This brings me to planning the next steps for the blog's growth.  \n\n  \n##### Next Steps  \nNext, I will continue to add more content. I have several topics in progress, from conceptual and informational blogs to more exploratory posts on tools like Loveable, Cursor, Replit, and n8n. I also want to try more Vibe Coding by enhancing my existing CLI tools, exploring some \"big ideas,\" or adding more automation to my daily tasks.  \n\n  \n##### Summary of Tools  \nIn conclusion, here's a summary of the full list of tools I used to build this site and how I used them:  \n\n| Tool                                        | Use-Case                               |\n| ------------------------------------------- | -------------------------------------- |\n| GitHub Copilot (Claude Sonnet & GPT models) | Vibe Coding, code assistance in VSCode |\n| VSCode                                      | IDE for development                    |\n| Node                                        | Tech stack backend development         |\n| ReactJS                                     | Tech stack frontend development        |\n| Tailwind CSS                                | Tech stack styling                     |\n| GitHub Copilot                              | SVG generation                         |\n| MidJourney                                  | Blog cover photo generation            |\n| ChatGPT, Grok, Perplexity                   | Deep search & research notes           |\n| NotebookLLM, ChatGPT                        | Research summarization & synthesizing  |\n| NotebookLLM                                 | MindMaps                               |\n| Obsidian                                    | Notes application                      |\n| GitHub Pages & Actions                      | Hosting & automated deployment         |\n| NotebookLLM                                 | Audio summaries of blogs               |\n\n##### Conclusion  \nBuilding this site and exploring new tools has been an eye-opening experience. Although it's still unclear how these changes will affect Product Engineering, I believe these tools will help professionals more than replace us. If there’s one thing I’ve learned, it's that once the change is embraced, the fun actually begins.\n\n\n---\n"
}